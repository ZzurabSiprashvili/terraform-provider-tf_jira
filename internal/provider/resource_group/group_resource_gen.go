// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_group

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func GroupResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"access_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The access level of a group. Valid values: 'site-admin', 'admin', 'user'.",
				MarkdownDescription: "The access level of a group. Valid values: 'site-admin', 'admin', 'user'.",
			},
			"application_key": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The application key of the product user groups to search for. Valid values: 'jira-servicedesk', 'jira-software', 'jira-product-discovery', 'jira-core'.",
				MarkdownDescription: "The application key of the product user groups to search for. Valid values: 'jira-servicedesk', 'jira-software', 'jira-product-discovery', 'jira-core'.",
			},
			"expand": schema.StringAttribute{
				Computed:            true,
				Description:         "Expand options that include additional group details in the response.",
				MarkdownDescription: "Expand options that include additional group details in the response.",
			},
			"group_id": schema.StringAttribute{
				Computed:            true,
				Description:         "The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.",
				MarkdownDescription: "The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.",
			},
			"group_name": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "The name of a group. To specify multiple names, pass multiple `groupName` parameters. For example, `groupName=administrators&groupName=jira-software-users`.",
				MarkdownDescription: "The name of a group. To specify multiple names, pass multiple `groupName` parameters. For example, `groupName=administrators&groupName=jira-software-users`.",
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"is_last": schema.BoolAttribute{
				Computed:            true,
				Description:         "Whether this is the last page.",
				MarkdownDescription: "Whether this is the last page.",
			},
			"max_results": schema.Int64Attribute{
				Computed:            true,
				Description:         "The maximum number of items that could be returned.",
				MarkdownDescription: "The maximum number of items that could be returned.",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the group.",
				MarkdownDescription: "The name of the group.",
			},
			"next_page": schema.StringAttribute{
				Computed:            true,
				Description:         "If there is another page of results, the URL of the next page.",
				MarkdownDescription: "If there is another page of results, the URL of the next page.",
			},
			"self": schema.StringAttribute{
				Computed:            true,
				Description:         "The URL for these group details.",
				MarkdownDescription: "The URL for these group details.",
			},
			"start_at": schema.Int64Attribute{
				Computed:            true,
				Description:         "The index of the first item returned.",
				MarkdownDescription: "The index of the first item returned.",
			},
			"total": schema.Int64Attribute{
				Computed:            true,
				Description:         "The number of items returned.",
				MarkdownDescription: "The number of items returned.",
			},
			"users": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"endindex": schema.Int64Attribute{
						Computed:            true,
						Description:         "The index of the last item returned on the page.",
						MarkdownDescription: "The index of the last item returned on the page.",
					},
					"items": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"account_id": schema.StringAttribute{
									Computed:            true,
									Description:         "The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.",
									MarkdownDescription: "The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.",
								},
								"account_type": schema.StringAttribute{
									Computed:            true,
									Description:         "The type of account represented by this user. This will be one of 'atlassian' (normal users), 'app' (application user) or 'customer' (Jira Service Desk customer user)",
									MarkdownDescription: "The type of account represented by this user. This will be one of 'atlassian' (normal users), 'app' (application user) or 'customer' (Jira Service Desk customer user)",
								},
								"active": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether the user is active.",
									MarkdownDescription: "Whether the user is active.",
								},
								"avatar_urls": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"x16": schema.StringAttribute{
											Computed:            true,
											Description:         "The URL of the item's 16x16 pixel avatar.",
											MarkdownDescription: "The URL of the item's 16x16 pixel avatar.",
										},
										"x24": schema.StringAttribute{
											Computed:            true,
											Description:         "The URL of the item's 24x24 pixel avatar.",
											MarkdownDescription: "The URL of the item's 24x24 pixel avatar.",
										},
										"x32": schema.StringAttribute{
											Computed:            true,
											Description:         "The URL of the item's 32x32 pixel avatar.",
											MarkdownDescription: "The URL of the item's 32x32 pixel avatar.",
										},
										"x48": schema.StringAttribute{
											Computed:            true,
											Description:         "The URL of the item's 48x48 pixel avatar.",
											MarkdownDescription: "The URL of the item's 48x48 pixel avatar.",
										},
									},
									CustomType: AvatarUrlsType{
										ObjectType: types.ObjectType{
											AttrTypes: AvatarUrlsValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "The avatars of the user.",
									MarkdownDescription: "The avatars of the user.",
								},
								"display_name": schema.StringAttribute{
									Computed:            true,
									Description:         "The display name of the user. Depending on the user’s privacy settings, this may return an alternative value.",
									MarkdownDescription: "The display name of the user. Depending on the user’s privacy settings, this may return an alternative value.",
								},
								"email_address": schema.StringAttribute{
									Computed:            true,
									Description:         "The email address of the user. Depending on the user’s privacy settings, this may be returned as null.",
									MarkdownDescription: "The email address of the user. Depending on the user’s privacy settings, this may be returned as null.",
								},
								"key": schema.StringAttribute{
									Computed:            true,
									Description:         "This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.",
									MarkdownDescription: "This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.",
									MarkdownDescription: "This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.",
								},
								"self": schema.StringAttribute{
									Computed:            true,
									Description:         "The URL of the user.",
									MarkdownDescription: "The URL of the user.",
								},
								"time_zone": schema.StringAttribute{
									Computed:            true,
									Description:         "The time zone specified in the user's profile. Depending on the user’s privacy settings, this may be returned as null.",
									MarkdownDescription: "The time zone specified in the user's profile. Depending on the user’s privacy settings, this may be returned as null.",
								},
							},
							CustomType: ItemsType{
								ObjectType: types.ObjectType{
									AttrTypes: ItemsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "The list of items.",
						MarkdownDescription: "The list of items.",
					},
					"maxresults": schema.Int64Attribute{
						Computed:            true,
						Description:         "The maximum number of results that could be on the page.",
						MarkdownDescription: "The maximum number of results that could be on the page.",
					},
					"size": schema.Int64Attribute{
						Computed:            true,
						Description:         "The number of items on the page.",
						MarkdownDescription: "The number of items on the page.",
					},
					"startindex": schema.Int64Attribute{
						Computed:            true,
						Description:         "The index of the first item returned on the page.",
						MarkdownDescription: "The index of the first item returned on the page.",
					},
				},
				CustomType: UsersType{
					ObjectType: types.ObjectType{
						AttrTypes: UsersValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "A paginated list of the users that are members of the group. A maximum of 50 users is returned in the list, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 50 users, use`?expand=users[51:100]`.",
				MarkdownDescription: "A paginated list of the users that are members of the group. A maximum of 50 users is returned in the list, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 50 users, use`?expand=users[51:100]`.",
			},
			"values": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"group_id": schema.StringAttribute{
							Computed:            true,
							Description:         "The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.",
							MarkdownDescription: "The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "The name of the group.",
							MarkdownDescription: "The name of the group.",
						},
					},
					CustomType: ValuesType{
						ObjectType: types.ObjectType{
							AttrTypes: ValuesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "The list of items.",
				MarkdownDescription: "The list of items.",
			},
		},
	}
}

type GroupModel struct {
	AccessType     types.String `tfsdk:"access_type"`
	ApplicationKey types.String `tfsdk:"application_key"`
	Expand         types.String `tfsdk:"expand"`
	GroupId        types.String `tfsdk:"group_id"`
	GroupName      types.List   `tfsdk:"group_name"`
	IsLast         types.Bool   `tfsdk:"is_last"`
	MaxResults     types.Int64  `tfsdk:"max_results"`
	Name           types.String `tfsdk:"name"`
	NextPage       types.String `tfsdk:"next_page"`
	Self           types.String `tfsdk:"self"`
	StartAt        types.Int64  `tfsdk:"start_at"`
	Total          types.Int64  `tfsdk:"total"`
	Users          UsersValue   `tfsdk:"users"`
	Values         types.List   `tfsdk:"values"`
}

var _ basetypes.ObjectTypable = UsersType{}

type UsersType struct {
	basetypes.ObjectType
}

func (t UsersType) Equal(o attr.Type) bool {
	other, ok := o.(UsersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsersType) String() string {
	return "UsersType"
}

func (t UsersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endindexAttribute, ok := attributes["endindex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endindex is missing from object`)

		return nil, diags
	}

	endindexVal, ok := endindexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endindex expected to be basetypes.Int64Value, was: %T`, endindexAttribute))
	}

	itemsAttribute, ok := attributes["items"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`items is missing from object`)

		return nil, diags
	}

	itemsVal, ok := itemsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`items expected to be basetypes.ListValue, was: %T`, itemsAttribute))
	}

	maxresultsAttribute, ok := attributes["maxresults"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maxresults is missing from object`)

		return nil, diags
	}

	maxresultsVal, ok := maxresultsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maxresults expected to be basetypes.Int64Value, was: %T`, maxresultsAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	startindexAttribute, ok := attributes["startindex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`startindex is missing from object`)

		return nil, diags
	}

	startindexVal, ok := startindexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`startindex expected to be basetypes.Int64Value, was: %T`, startindexAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsersValue{
		Endindex:   endindexVal,
		Items:      itemsVal,
		Maxresults: maxresultsVal,
		Size:       sizeVal,
		Startindex: startindexVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewUsersValueNull() UsersValue {
	return UsersValue{
		state: attr.ValueStateNull,
	}
}

func NewUsersValueUnknown() UsersValue {
	return UsersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsersValue Attribute Value",
				"While creating a UsersValue value, a missing attribute value was detected. "+
					"A UsersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsersValue Attribute Type",
				"While creating a UsersValue value, an invalid attribute value was detected. "+
					"A UsersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsersValue Attribute Value",
				"While creating a UsersValue value, an extra attribute value was detected. "+
					"A UsersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsersValueUnknown(), diags
	}

	endindexAttribute, ok := attributes["endindex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endindex is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	endindexVal, ok := endindexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endindex expected to be basetypes.Int64Value, was: %T`, endindexAttribute))
	}

	itemsAttribute, ok := attributes["items"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`items is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	itemsVal, ok := itemsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`items expected to be basetypes.ListValue, was: %T`, itemsAttribute))
	}

	maxresultsAttribute, ok := attributes["maxresults"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maxresults is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	maxresultsVal, ok := maxresultsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maxresults expected to be basetypes.Int64Value, was: %T`, maxresultsAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	startindexAttribute, ok := attributes["startindex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`startindex is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	startindexVal, ok := startindexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`startindex expected to be basetypes.Int64Value, was: %T`, startindexAttribute))
	}

	if diags.HasError() {
		return NewUsersValueUnknown(), diags
	}

	return UsersValue{
		Endindex:   endindexVal,
		Items:      itemsVal,
		Maxresults: maxresultsVal,
		Size:       sizeVal,
		Startindex: startindexVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewUsersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsersValue {
	object, diags := NewUsersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsersValueMust(UsersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsersType) ValueType(ctx context.Context) attr.Value {
	return UsersValue{}
}

var _ basetypes.ObjectValuable = UsersValue{}

type UsersValue struct {
	Endindex   basetypes.Int64Value `tfsdk:"endindex"`
	Items      basetypes.ListValue  `tfsdk:"items"`
	Maxresults basetypes.Int64Value `tfsdk:"maxresults"`
	Size       basetypes.Int64Value `tfsdk:"size"`
	Startindex basetypes.Int64Value `tfsdk:"startindex"`
	state      attr.ValueState
}

func (v UsersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["endindex"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["items"] = basetypes.ListType{
		ElemType: ItemsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["maxresults"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["startindex"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Endindex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endindex"] = val

		val, err = v.Items.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["items"] = val

		val, err = v.Maxresults.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maxresults"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		val, err = v.Startindex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["startindex"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsersValue) String() string {
	return "UsersValue"
}

func (v UsersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	items := types.ListValueMust(
		ItemsType{
			basetypes.ObjectType{
				AttrTypes: ItemsValue{}.AttributeTypes(ctx),
			},
		},
		v.Items.Elements(),
	)

	if v.Items.IsNull() {
		items = types.ListNull(
			ItemsType{
				basetypes.ObjectType{
					AttrTypes: ItemsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Items.IsUnknown() {
		items = types.ListUnknown(
			ItemsType{
				basetypes.ObjectType{
					AttrTypes: ItemsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"endindex": basetypes.Int64Type{},
		"items": basetypes.ListType{
			ElemType: ItemsValue{}.Type(ctx),
		},
		"maxresults": basetypes.Int64Type{},
		"size":       basetypes.Int64Type{},
		"startindex": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"endindex":   v.Endindex,
			"items":      items,
			"maxresults": v.Maxresults,
			"size":       v.Size,
			"startindex": v.Startindex,
		})

	return objVal, diags
}

func (v UsersValue) Equal(o attr.Value) bool {
	other, ok := o.(UsersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Endindex.Equal(other.Endindex) {
		return false
	}

	if !v.Items.Equal(other.Items) {
		return false
	}

	if !v.Maxresults.Equal(other.Maxresults) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	if !v.Startindex.Equal(other.Startindex) {
		return false
	}

	return true
}

func (v UsersValue) Type(ctx context.Context) attr.Type {
	return UsersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"endindex": basetypes.Int64Type{},
		"items": basetypes.ListType{
			ElemType: ItemsValue{}.Type(ctx),
		},
		"maxresults": basetypes.Int64Type{},
		"size":       basetypes.Int64Type{},
		"startindex": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountIdAttribute, ok := attributes["account_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_id is missing from object`)

		return nil, diags
	}

	accountIdVal, ok := accountIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_id expected to be basetypes.StringValue, was: %T`, accountIdAttribute))
	}

	accountTypeAttribute, ok := attributes["account_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_type is missing from object`)

		return nil, diags
	}

	accountTypeVal, ok := accountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_type expected to be basetypes.StringValue, was: %T`, accountTypeAttribute))
	}

	activeAttribute, ok := attributes["active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`active is missing from object`)

		return nil, diags
	}

	activeVal, ok := activeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`active expected to be basetypes.BoolValue, was: %T`, activeAttribute))
	}

	avatarUrlsAttribute, ok := attributes["avatar_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avatar_urls is missing from object`)

		return nil, diags
	}

	avatarUrlsVal, ok := avatarUrlsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avatar_urls expected to be basetypes.ObjectValue, was: %T`, avatarUrlsAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	emailAddressAttribute, ok := attributes["email_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email_address is missing from object`)

		return nil, diags
	}

	emailAddressVal, ok := emailAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email_address expected to be basetypes.StringValue, was: %T`, emailAddressAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return nil, diags
	}

	selfVal, ok := selfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.StringValue, was: %T`, selfAttribute))
	}

	timeZoneAttribute, ok := attributes["time_zone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_zone is missing from object`)

		return nil, diags
	}

	timeZoneVal, ok := timeZoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_zone expected to be basetypes.StringValue, was: %T`, timeZoneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		AccountId:    accountIdVal,
		AccountType:  accountTypeVal,
		Active:       activeVal,
		AvatarUrls:   avatarUrlsVal,
		DisplayName:  displayNameVal,
		EmailAddress: emailAddressVal,
		Key:          keyVal,
		Name:         nameVal,
		Self:         selfVal,
		TimeZone:     timeZoneVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	accountIdAttribute, ok := attributes["account_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_id is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	accountIdVal, ok := accountIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_id expected to be basetypes.StringValue, was: %T`, accountIdAttribute))
	}

	accountTypeAttribute, ok := attributes["account_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_type is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	accountTypeVal, ok := accountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_type expected to be basetypes.StringValue, was: %T`, accountTypeAttribute))
	}

	activeAttribute, ok := attributes["active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`active is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	activeVal, ok := activeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`active expected to be basetypes.BoolValue, was: %T`, activeAttribute))
	}

	avatarUrlsAttribute, ok := attributes["avatar_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avatar_urls is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	avatarUrlsVal, ok := avatarUrlsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avatar_urls expected to be basetypes.ObjectValue, was: %T`, avatarUrlsAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	emailAddressAttribute, ok := attributes["email_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email_address is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	emailAddressVal, ok := emailAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email_address expected to be basetypes.StringValue, was: %T`, emailAddressAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	selfVal, ok := selfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.StringValue, was: %T`, selfAttribute))
	}

	timeZoneAttribute, ok := attributes["time_zone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_zone is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	timeZoneVal, ok := timeZoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_zone expected to be basetypes.StringValue, was: %T`, timeZoneAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		AccountId:    accountIdVal,
		AccountType:  accountTypeVal,
		Active:       activeVal,
		AvatarUrls:   avatarUrlsVal,
		DisplayName:  displayNameVal,
		EmailAddress: emailAddressVal,
		Key:          keyVal,
		Name:         nameVal,
		Self:         selfVal,
		TimeZone:     timeZoneVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	AccountId    basetypes.StringValue `tfsdk:"account_id"`
	AccountType  basetypes.StringValue `tfsdk:"account_type"`
	Active       basetypes.BoolValue   `tfsdk:"active"`
	AvatarUrls   basetypes.ObjectValue `tfsdk:"avatar_urls"`
	DisplayName  basetypes.StringValue `tfsdk:"display_name"`
	EmailAddress basetypes.StringValue `tfsdk:"email_address"`
	Key          basetypes.StringValue `tfsdk:"key"`
	Name         basetypes.StringValue `tfsdk:"name"`
	Self         basetypes.StringValue `tfsdk:"self"`
	TimeZone     basetypes.StringValue `tfsdk:"time_zone"`
	state        attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["account_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["account_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["avatar_urls"] = basetypes.ObjectType{
		AttrTypes: AvatarUrlsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["email_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["self"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["time_zone"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AccountId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account_id"] = val

		val, err = v.AccountType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account_type"] = val

		val, err = v.Active.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["active"] = val

		val, err = v.AvatarUrls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["avatar_urls"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.EmailAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email_address"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Self.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["self"] = val

		val, err = v.TimeZone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["time_zone"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var avatarUrls basetypes.ObjectValue

	if v.AvatarUrls.IsNull() {
		avatarUrls = types.ObjectNull(
			AvatarUrlsValue{}.AttributeTypes(ctx),
		)
	}

	if v.AvatarUrls.IsUnknown() {
		avatarUrls = types.ObjectUnknown(
			AvatarUrlsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AvatarUrls.IsNull() && !v.AvatarUrls.IsUnknown() {
		avatarUrls = types.ObjectValueMust(
			AvatarUrlsValue{}.AttributeTypes(ctx),
			v.AvatarUrls.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"account_id":   basetypes.StringType{},
		"account_type": basetypes.StringType{},
		"active":       basetypes.BoolType{},
		"avatar_urls": basetypes.ObjectType{
			AttrTypes: AvatarUrlsValue{}.AttributeTypes(ctx),
		},
		"display_name":  basetypes.StringType{},
		"email_address": basetypes.StringType{},
		"key":           basetypes.StringType{},
		"name":          basetypes.StringType{},
		"self":          basetypes.StringType{},
		"time_zone":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"account_id":    v.AccountId,
			"account_type":  v.AccountType,
			"active":        v.Active,
			"avatar_urls":   avatarUrls,
			"display_name":  v.DisplayName,
			"email_address": v.EmailAddress,
			"key":           v.Key,
			"name":          v.Name,
			"self":          v.Self,
			"time_zone":     v.TimeZone,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccountId.Equal(other.AccountId) {
		return false
	}

	if !v.AccountType.Equal(other.AccountType) {
		return false
	}

	if !v.Active.Equal(other.Active) {
		return false
	}

	if !v.AvatarUrls.Equal(other.AvatarUrls) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.EmailAddress.Equal(other.EmailAddress) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Self.Equal(other.Self) {
		return false
	}

	if !v.TimeZone.Equal(other.TimeZone) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"account_id":   basetypes.StringType{},
		"account_type": basetypes.StringType{},
		"active":       basetypes.BoolType{},
		"avatar_urls": basetypes.ObjectType{
			AttrTypes: AvatarUrlsValue{}.AttributeTypes(ctx),
		},
		"display_name":  basetypes.StringType{},
		"email_address": basetypes.StringType{},
		"key":           basetypes.StringType{},
		"name":          basetypes.StringType{},
		"self":          basetypes.StringType{},
		"time_zone":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AvatarUrlsType{}

type AvatarUrlsType struct {
	basetypes.ObjectType
}

func (t AvatarUrlsType) Equal(o attr.Type) bool {
	other, ok := o.(AvatarUrlsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AvatarUrlsType) String() string {
	return "AvatarUrlsType"
}

func (t AvatarUrlsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	x16Attribute, ok := attributes["x16"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x16 is missing from object`)

		return nil, diags
	}

	x16Val, ok := x16Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x16 expected to be basetypes.StringValue, was: %T`, x16Attribute))
	}

	x24Attribute, ok := attributes["x24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x24 is missing from object`)

		return nil, diags
	}

	x24Val, ok := x24Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x24 expected to be basetypes.StringValue, was: %T`, x24Attribute))
	}

	x32Attribute, ok := attributes["x32"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x32 is missing from object`)

		return nil, diags
	}

	x32Val, ok := x32Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x32 expected to be basetypes.StringValue, was: %T`, x32Attribute))
	}

	x48Attribute, ok := attributes["x48"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x48 is missing from object`)

		return nil, diags
	}

	x48Val, ok := x48Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x48 expected to be basetypes.StringValue, was: %T`, x48Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AvatarUrlsValue{
		X16:   x16Val,
		X24:   x24Val,
		X32:   x32Val,
		X48:   x48Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewAvatarUrlsValueNull() AvatarUrlsValue {
	return AvatarUrlsValue{
		state: attr.ValueStateNull,
	}
}

func NewAvatarUrlsValueUnknown() AvatarUrlsValue {
	return AvatarUrlsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAvatarUrlsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AvatarUrlsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AvatarUrlsValue Attribute Value",
				"While creating a AvatarUrlsValue value, a missing attribute value was detected. "+
					"A AvatarUrlsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AvatarUrlsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AvatarUrlsValue Attribute Type",
				"While creating a AvatarUrlsValue value, an invalid attribute value was detected. "+
					"A AvatarUrlsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AvatarUrlsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AvatarUrlsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AvatarUrlsValue Attribute Value",
				"While creating a AvatarUrlsValue value, an extra attribute value was detected. "+
					"A AvatarUrlsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AvatarUrlsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAvatarUrlsValueUnknown(), diags
	}

	x16Attribute, ok := attributes["x16"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x16 is missing from object`)

		return NewAvatarUrlsValueUnknown(), diags
	}

	x16Val, ok := x16Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x16 expected to be basetypes.StringValue, was: %T`, x16Attribute))
	}

	x24Attribute, ok := attributes["x24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x24 is missing from object`)

		return NewAvatarUrlsValueUnknown(), diags
	}

	x24Val, ok := x24Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x24 expected to be basetypes.StringValue, was: %T`, x24Attribute))
	}

	x32Attribute, ok := attributes["x32"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x32 is missing from object`)

		return NewAvatarUrlsValueUnknown(), diags
	}

	x32Val, ok := x32Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x32 expected to be basetypes.StringValue, was: %T`, x32Attribute))
	}

	x48Attribute, ok := attributes["x48"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x48 is missing from object`)

		return NewAvatarUrlsValueUnknown(), diags
	}

	x48Val, ok := x48Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x48 expected to be basetypes.StringValue, was: %T`, x48Attribute))
	}

	if diags.HasError() {
		return NewAvatarUrlsValueUnknown(), diags
	}

	return AvatarUrlsValue{
		X16:   x16Val,
		X24:   x24Val,
		X32:   x32Val,
		X48:   x48Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewAvatarUrlsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AvatarUrlsValue {
	object, diags := NewAvatarUrlsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAvatarUrlsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AvatarUrlsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAvatarUrlsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAvatarUrlsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAvatarUrlsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAvatarUrlsValueMust(AvatarUrlsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AvatarUrlsType) ValueType(ctx context.Context) attr.Value {
	return AvatarUrlsValue{}
}

var _ basetypes.ObjectValuable = AvatarUrlsValue{}

type AvatarUrlsValue struct {
	X16   basetypes.StringValue `tfsdk:"x16"`
	X24   basetypes.StringValue `tfsdk:"x24"`
	X32   basetypes.StringValue `tfsdk:"x32"`
	X48   basetypes.StringValue `tfsdk:"x48"`
	state attr.ValueState
}

func (v AvatarUrlsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["x16"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["x24"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["x32"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["x48"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.X16.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["x16"] = val

		val, err = v.X24.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["x24"] = val

		val, err = v.X32.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["x32"] = val

		val, err = v.X48.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["x48"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AvatarUrlsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AvatarUrlsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AvatarUrlsValue) String() string {
	return "AvatarUrlsValue"
}

func (v AvatarUrlsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"x16": basetypes.StringType{},
		"x24": basetypes.StringType{},
		"x32": basetypes.StringType{},
		"x48": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"x16": v.X16,
			"x24": v.X24,
			"x32": v.X32,
			"x48": v.X48,
		})

	return objVal, diags
}

func (v AvatarUrlsValue) Equal(o attr.Value) bool {
	other, ok := o.(AvatarUrlsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.X16.Equal(other.X16) {
		return false
	}

	if !v.X24.Equal(other.X24) {
		return false
	}

	if !v.X32.Equal(other.X32) {
		return false
	}

	if !v.X48.Equal(other.X48) {
		return false
	}

	return true
}

func (v AvatarUrlsValue) Type(ctx context.Context) attr.Type {
	return AvatarUrlsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AvatarUrlsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"x16": basetypes.StringType{},
		"x24": basetypes.StringType{},
		"x32": basetypes.StringType{},
		"x48": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ValuesType{}

type ValuesType struct {
	basetypes.ObjectType
}

func (t ValuesType) Equal(o attr.Type) bool {
	other, ok := o.(ValuesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ValuesType) String() string {
	return "ValuesType"
}

func (t ValuesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return nil, diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ValuesValue{
		GroupId: groupIdVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewValuesValueNull() ValuesValue {
	return ValuesValue{
		state: attr.ValueStateNull,
	}
}

func NewValuesValueUnknown() ValuesValue {
	return ValuesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewValuesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ValuesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ValuesValue Attribute Value",
				"While creating a ValuesValue value, a missing attribute value was detected. "+
					"A ValuesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ValuesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ValuesValue Attribute Type",
				"While creating a ValuesValue value, an invalid attribute value was detected. "+
					"A ValuesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ValuesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ValuesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ValuesValue Attribute Value",
				"While creating a ValuesValue value, an extra attribute value was detected. "+
					"A ValuesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ValuesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewValuesValueUnknown(), diags
	}

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return NewValuesValueUnknown(), diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewValuesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewValuesValueUnknown(), diags
	}

	return ValuesValue{
		GroupId: groupIdVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewValuesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ValuesValue {
	object, diags := NewValuesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewValuesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ValuesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewValuesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewValuesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewValuesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewValuesValueMust(ValuesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ValuesType) ValueType(ctx context.Context) attr.Value {
	return ValuesValue{}
}

var _ basetypes.ObjectValuable = ValuesValue{}

type ValuesValue struct {
	GroupId basetypes.StringValue `tfsdk:"group_id"`
	Name    basetypes.StringValue `tfsdk:"name"`
	state   attr.ValueState
}

func (v ValuesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["group_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.GroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ValuesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ValuesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ValuesValue) String() string {
	return "ValuesValue"
}

func (v ValuesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group_id": basetypes.StringType{},
		"name":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group_id": v.GroupId,
			"name":     v.Name,
		})

	return objVal, diags
}

func (v ValuesValue) Equal(o attr.Value) bool {
	other, ok := o.(ValuesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.GroupId.Equal(other.GroupId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ValuesValue) Type(ctx context.Context) attr.Type {
	return ValuesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ValuesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group_id": basetypes.StringType{},
		"name":     basetypes.StringType{},
	}
}
